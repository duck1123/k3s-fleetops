{:paths ["src"]
 :deps  {io.github.l3nz/cli-matic {:sha "ddbcad077ba63e0abb3597a7ec6f62c40f91c9e5"}}
 :tasks
 {:requires
  ([babashka.fs :as fs]
   [clojure.string :as str]
   [k3s-fleetops.core :as c]
   [k3s-fleetops.postgres :as pg])

  apply-git-hooks
  {:doc  "Register git hooks"
   :task (shell "git config core.hooksPath .githooks")}

  apply-master-application
  {:doc     "Install 00-master argo application"
   :depends [build]
   :task    (shell "kubectl apply -f target/infra-manifests/00-master.yaml")}

  build
  {:doc  "Convert all edn files to yaml"
   :task (exec 'k3s-fleetops.core/build {})}

  build-charts
  {:doc  "Build nixidy charts"
   :task (shell "nixidy build .#dev")}

  ci
  {:doc     "Run all build steps"
   :depends [clean generate switch-charts]}

  clean
  {:doc  "Clean generated files"
   :task (shell "rm -rf target")}

  create-harbor-password-secret
  {:doc  "Create secret for Harbor"
   :task (c/create-sealed-secret :harbor)}

  create-keycloak-password-secret
  {:doc  "Create secret for Keycloak"
   :task (c/create-sealed-secret :keycloak)}

  create-sealed-secret
  {:doc  "Create sealed secrets"
   :task (exec 'k3s-fleetops.core/create-sealed-secret-command {})}

  create-secret
  {:doc  "Create secrets"
   :task (exec 'k3s-fleetops.core/create-secret-command {})}

  decrypt
  {:doc "Extract secrets from encrypted form"
   :task
   (shell "sh -c \"sops --decrypt secrets.enc.yaml > secrets/secrets.yaml\"")}

  delete-secret-controller
  {:doc "Delete the sealed secrets controller"
   :task
   (let [namespace "sealed-secrets"
         command   (str "kubectl -n \"" namespace "\" delete pod -l name=sealed-secrets-controller")]
     (shell command))}

  edit-secrets
  {:doc "Edit secrets in the encrypted file in place (no plaintext file). Alternative: bb decrypt, edit secrets/secrets.yaml, bb encrypt."
   :task
   (shell "sops secrets.enc.yaml")}

  encrypt
  {:doc "Update secrets with latest changes"
   :task
   (shell "sh -c \"sops --encrypt secrets/secrets.yaml > secrets.enc.yaml\"")}

  format
  {:doc  "format code"
   :task (shell "find . -name '*.nix' -exec nixfmt {} +")}

  forward-argocd
  {:doc  "Forward the argocd port"
   :task (shell "kubectl port-forward svc/argocd-server -n argocd 8080:443")}

  forward-traefik-dashboard
  {:doc "Expose traefik dashboard"
   :task
   (do
     (let [get-name-command "kubectl get pods --selector \"app.kubernetes.io/name=traefik\" --output=name"
           pod-name         (shell get-name-command)
           command          (str "kubectl port-forward " pod-name " 9000:9000")]
       (shell command)))}

  generate
  {:doc  "Run CRD generators"
   :task (shell "nix run '.#generate'")}

  ;; https://github.com/bitnami-labs/sealed-secrets/blob/main/docs/bring-your-own-certificates.md
  install-sealed-key
  {:doc "Upload sealed secrets key"
   :task
   (let [dry-run?    false
         namespace   "sealed-secrets"
         secret-name "imported-secret"
         public-key  "tls.crt"
         private-key "tls.key"
         command     (str
                      "kubectl "
                      "-n \"" namespace "\" "
                      "create secret tls "
                      "\"" secret-name "\" "
                      "--cert=\"" public-key "\" "
                      "--key=\"" private-key "\" ")]
     (if dry-run?
       (println command)
       (shell command)))}

  post-process-manifests
  {:doc  "Post-process generated manifests to fix nixidy hardcoded behaviors"
   :task (let [script-path (str/trim (:out (shell {:out :string} "nix-build --no-link --expr '(import <nixpkgs> {}).callPackage ./lib/postProcessManifests.nix {}'")))]
           (shell (str script-path "/bin/post-process-manifests")))}

  switch-charts
  {:doc     "Switch nixidy charts"
   :depends [post-process-manifests]
   :task (let [show-trace?    (= (System/getenv "SHOW_TRACE") "true")
               env            "dev"
               args           (concat ["nix"
                                       "run"
                                       "nixpkgs#nix-output-monitor"
                                       "--"
                                       "build"
                                       (str ".#nixidyEnvs.x86_64-linux." env ".activationPackage")
                                       ;; Read environment
                                       "--impure"
                                       ;; Don't create results directory
                                       "--no-link"
                                       ;; See all output
                                       "--print-out-paths"]
                                      (when show-trace? ["--show-trace"]))
               ;; Nix build needs secrets from encrypted file; decrypt to temp and run
               drv-path       (str/trim (:out (apply shell (into [{:out :string} "./scripts/with-decrypted-secrets.sh"] args))))
               activation-cmd (str drv-path "/activate")]
           #_(binding [*out* *err*] (println "path: " activation-cmd))
           (shell activation-cmd)
           ;; Run post-processing after nixidy generates manifests
           (let [post-process-path (str/trim (:out (shell {:out :string} "nix-build --no-link --expr '(import <nixpkgs> {}).callPackage ./lib/postProcessManifests.nix {}'")))
                 post-process-cmd  (str post-process-path "/bin/post-process-manifests")]
             (shell post-process-cmd)))}

  update-charts
  {:doc  "Update Helm chart archives from OCI registries"
   :task (shell "sh -c 'cd chart-archives && sh pull-charts.sh'")}

  generate-key-file
  {:doc  "Generate random keyfile"
   :task (shell "openssl rand -out keepass.keyx 256")}

  k3d-create
  {:doc  "Create a k3d cluster"
   :task (c/k3d-create)}

  apply-sealed-key-label
  {:doc "Marked the sealed key as active"
   :task
   (let [dry-run?    false
         namespace   "sealed-secrets"
         secret-name "imported-secret"
         command     (str "kubectl -n \"" namespace  "\" label secret \"" secret-name  "\" sealedsecrets.bitnami.com/sealed-secrets-key=active")]
     (if dry-run?
       (println command)
       (shell command)))}

  mariadb-list-backups
  {:doc "List available MariaDB backups"
   :task
   (let [namespace "mariadb"
         temp-pod  "mariadb-backup-lister"
         job-yaml  (str "apiVersion: v1
kind: Pod
metadata:
  name: " temp-pod "
  namespace: " namespace "
spec:
  restartPolicy: Never
  containers:
  - name: lister
    image: bitnami/mariadb:latest
    command: [\"/bin/bash\", \"-c\", \"ls -lh /backups/*.sql.gz 2>/dev/null || echo 'No backups found'\"]
    volumeMounts:
    - name: backups
      mountPath: /backups
  volumes:
  - name: backups
    persistentVolumeClaim:
      claimName: mariadb-backups")]
     (shell {:in job-yaml} "kubectl apply -f -")
     (shell (str "kubectl wait --for=condition=Ready pod/" temp-pod " -n " namespace " --timeout=30s || true"))
     (shell (str "kubectl logs " temp-pod " -n " namespace))
     (shell (str "kubectl delete pod " temp-pod " -n " namespace " --ignore-not-found=true")))}

  mariadb-restore
  {:doc "Restore MariaDB from a backup file. Usage: BACKUP_FILE=filename.sql.gz bb mariadb-restore"
   :task
   (let [namespace "mariadb"
         backup-file (or (System/getenv "BACKUP_FILE")
                        (do
                          (println "Available backups:")
                          (shell (str "bb mariadb-list-backups"))
                          (print "Enter backup filename (e.g., mariadb-backup-20250101_020000.sql.gz): ")
                          (flush)
                          (read-line)))
         _          (when (or (nil? backup-file) (empty? backup-file))
                     (println "Error: Backup file is required")
                     (System/exit 1))
         job-name   (str "mariadb-restore-" (System/currentTimeMillis))
         job-yaml   (str "apiVersion: batch/v1
kind: Job
metadata:
  name: " job-name "
  namespace: " namespace "
spec:
  ttlSecondsAfterFinished: 300
  template:
    spec:
      restartPolicy: Never
      containers:
      - name: restore
        image: bitnami/mariadb:latest
        command:
        - /bin/bash
        - -c
        - |
          set -e
          echo \"Starting restore from: " backup-file "\"
          echo \"WARNING: This will replace all existing databases!\"
          gunzip -c /backups/" backup-file " | mysql -h mariadb.mariadb -u root -p\"$MARIADB_ROOT_PASSWORD\"
          echo \"Restore completed successfully!\"
        env:
        - name: MARIADB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mariadb-password
              key: mariadb-root-password
        volumeMounts:
        - name: backups
          mountPath: /backups
      volumes:
      - name: backups
        persistentVolumeClaim:
          claimName: mariadb-backups")]
     (println "Creating restore job...")
     (shell {:in job-yaml} "kubectl apply -f -")
     (println "Restore job created: " job-name)
     (println "Monitor progress with: kubectl logs -n " namespace " -f job/" job-name)
     (println "Or watch the job: kubectl get job -n " namespace " " job-name " -w"))}

  postgres-list
  {:doc "List all PostgreSQL databases and their sizes. Use --json for JSON output"
   :task (let [args *command-line-args*
               json? (some #{"--json" "-j"} args)]
           (pg/list-databases json?))}

  postgres-backup
  {:doc "Backup PostgreSQL databases. Usage: DATABASE=dbname OUTPUT_DIR=./backups bb postgres-backup (omit DATABASE to backup all)"
   :task (pg/backup-databases (System/getenv "DATABASE") (or (System/getenv "OUTPUT_DIR") "./backups/postgresql"))}

  postgres-restore
  {:doc "Restore PostgreSQL from a backup file. Usage: BACKUP_FILE=path/to/backup.sql.gz DATABASE=dbname [RECREATE=true] bb postgres-restore"
   :task (pg/restore-database (System/getenv "BACKUP_FILE") (System/getenv "DATABASE") (= "true" (System/getenv "RECREATE")))}
}}
